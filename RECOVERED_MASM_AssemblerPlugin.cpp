/*
========================================================================================
MASM ASSEMBLER PLUGIN - IMPLEMENTATION
========================================================================================
FEATURES:
- MASM Assembly Code Generation
- C++ Integration Support
- Assembly Optimization
- Direct MASM Compilation Support
- Plugin Architecture for BenignPacker Integration
- Visual Studio 2022 Native Compilation
========================================================================================
*/

#include "IPlugin.h"
#include <sstream>
#include <iomanip>
#include <random>
#include <chrono>
#include <thread>
#include <algorithm>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <string>
#include <vector>
#include <map>

namespace BenignPacker {

// MASM Assembler Plugin class
class MASMAssemblerPlugin : public IStubGenerator {
private:
    std::mt19937_64 rng;
    bool initialized;
    std::map<std::string, std::string> settings;

public:
    MASMAssemblerPlugin() : initialized(false) {
        InitializeRNG();
        LoadDefaultSettings();
    }

    ~MASMAssemblerPlugin() {
        // Cleanup
    }

    // IPlugin interface implementation
    PluginConfig GetConfig() const override {
        PluginConfig config;
        config.name = "MASMAssemblerPlugin";
        config.version = "1.0.0";
        config.description = "MASM Assembly Code Generation and Integration";
        config.author = "ItsMehRAWRXD";
        config.supportedFormats = {".asm", ".obj", ".exe", ".dll"};
        config.capabilities["assembly_generation"] = "true";
        config.capabilities["masm_support"] = "true";
        config.capabilities["optimization"] = "true";
        config.requiresAdmin = false;
        config.supportsEncryption = false;
        config.supportsPolymorphic = true;
        config.supportsAntiAnalysis = false;
        return config;
    }

    bool Initialize(const std::map<std::string, std::string>& settings) override {
        this->settings = settings;
        initialized = true;
        return true;
    }

    PluginResult Execute(const ExecutionContext& context) override {
        PluginResult result;
        
        if (!initialized) {
            result.success = false;
            result.message = "Plugin not initialized";
            return result;
        }

        try {
            // Read input file
            std::ifstream inputFile(context.inputFile, std::ios::binary);
            if (!inputFile.is_open()) {
                result.success = false;
                result.message = "Failed to open input file: " + context.inputFile;
                return result;
            }

            std::vector<uint8_t> payload((std::istreambuf_iterator<char>(inputFile)),
                                        std::istreambuf_iterator<char>());
            inputFile.close();

            // Generate MASM code
            std::vector<uint8_t> generatedCode = GenerateMASMCode(payload);

            // Write output file
            std::ofstream outputFile(context.outputFile, std::ios::binary);
            if (!outputFile.is_open()) {
                result.success = false;
                result.message = "Failed to open output file: " + context.outputFile;
                return result;
            }

            outputFile.write(reinterpret_cast<const char*>(generatedCode.data()), generatedCode.size());
            outputFile.close();

            result.success = true;
            result.message = "MASM code generated successfully";
            result.generatedData = generatedCode;
            result.metadata["input_size"] = std::to_string(payload.size());
            result.metadata["output_size"] = std::to_string(generatedCode.size());
            result.metadata["method"] = context.method;

        } catch (const std::exception& e) {
            result.success = false;
            result.message = "Exception occurred: " + std::string(e.what());
            result.errorDetails = e.what();
        }

        return result;
    }

    // IStubGenerator interface implementation
    std::vector<uint8_t> GenerateStub(const std::vector<uint8_t>& payload) override {
        return GenerateMASMCode(payload);
    }

private:
    void InitializeRNG() {
        auto seed = std::chrono::high_resolution_clock::now().time_since_epoch().count();
        rng.seed(static_cast<unsigned int>(seed));
    }

    void LoadDefaultSettings() {
        settings["optimization_level"] = "2";
        settings["target_architecture"] = "x64";
        settings["output_format"] = "obj";
    }

    std::vector<uint8_t> GenerateMASMCode(const std::vector<uint8_t>& payload) {
        std::stringstream masm_code;
        
        // Generate MASM header
        masm_code << "; Generated by MASMAssemblerPlugin\n";
        masm_code << ".model flat, stdcall\n";
        masm_code << ".code\n\n";
        
        // Generate data section
        masm_code << ".data\n";
        masm_code << "payload_data db ";
        
        for (size_t i = 0; i < payload.size(); ++i) {
            if (i > 0 && i % 16 == 0) {
                masm_code << "\n    db ";
            }
            masm_code << "0" << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(payload[i]) << "h";
            if (i < payload.size() - 1) {
                masm_code << ", ";
            }
        }
        masm_code << "\n";
        masm_code << "payload_size equ $ - payload_data\n\n";
        
        // Generate code section
        masm_code << ".code\n";
        masm_code << "main proc\n";
        masm_code << "    ; Allocate memory for payload\n";
        masm_code << "    push 0\n";
        masm_code << "    push MEM_COMMIT or MEM_RESERVE\n";
        masm_code << "    push payload_size\n";
        masm_code << "    push 0\n";
        masm_code << "    call VirtualAlloc\n";
        masm_code << "    test eax, eax\n";
        masm_code << "    jz exit_program\n\n";
        
        masm_code << "    ; Copy payload to allocated memory\n";
        masm_code << "    push payload_size\n";
        masm_code << "    push offset payload_data\n";
        masm_code << "    push eax\n";
        masm_code << "    call memcpy\n\n";
        
        masm_code << "    ; Execute payload\n";
        masm_code << "    call eax\n\n";
        
        masm_code << "    ; Cleanup\n";
        masm_code << "    push 0\n";
        masm_code << "    push MEM_RELEASE\n";
        masm_code << "    push eax\n";
        masm_code << "    call VirtualFree\n\n";
        
        masm_code << "exit_program:\n";
        masm_code << "    ret\n";
        masm_code << "main endp\n\n";
        
        masm_code << "end main\n";
        
        std::string masmCodeStr = masm_code.str();
        return std::vector<uint8_t>(masmCodeStr.begin(), masmCodeStr.end());
    }

    std::vector<uint8_t> GenerateCppCode(const std::vector<uint8_t>& payload) {
        std::stringstream cpp_code;
        
        cpp_code << "// Generated by MASMAssemblerPlugin - C++ Integration\n";
        cpp_code << "#include <windows.h>\n";
        cpp_code << "#include <iostream>\n";
        cpp_code << "#include <vector>\n\n";
        
        cpp_code << "extern \"C\" {\n";
        cpp_code << "    // MASM function declarations\n";
        cpp_code << "    extern void masm_main();\n";
        cpp_code << "    extern unsigned char payload_data[];\n";
        cpp_code << "    extern unsigned int payload_size;\n";
        cpp_code << "}\n\n";
        
        cpp_code << "int main() {\n";
        cpp_code << "    // Call MASM function\n";
        cpp_code << "    masm_main();\n";
        cpp_code << "    return 0;\n";
        cpp_code << "}\n";
        
        std::string cppCodeStr = cpp_code.str();
        return std::vector<uint8_t>(cppCodeStr.begin(), cppCodeStr.end());
    }
};

// Plugin factory functions
std::unique_ptr<IStubGenerator> CreateMASMAssemblerPlugin() {
    return std::make_unique<MASMAssemblerPlugin>();
}

void DestroyMASMAssemblerPlugin(IStubGenerator* plugin) {
    delete plugin;
}

// Export functions
extern "C" {
    __declspec(dllexport) BenignPacker::IStubGenerator* CreatePlugin() {
        return new MASMAssemblerPlugin();
    }
    
    __declspec(dllexport) void DestroyPlugin(BenignPacker::IStubGenerator* plugin) {
        delete plugin;
    }
    
    __declspec(dllexport) const char* GetPluginVersion() {
        return "1.0.0";
    }
    
    __declspec(dllexport) const char* GetPluginName() {
        return "MASMAssemblerPlugin";
    }
    
    __declspec(dllexport) const char* GetPluginDescription() {
        return "MASM Assembly Code Generation and Integration";
    }
    
    __declspec(dllexport) bool SupportsFormat(const char* format) {
        std::string fmt(format);
        return fmt == ".asm" || fmt == ".obj" || fmt == ".exe" || fmt == ".dll";
    }
    
    __declspec(dllexport) bool RequiresAdmin() {
        return false;
    }
    
    __declspec(dllexport) const char* GetSupportedMethods() {
        return "masm,cpp,obj,exe";
    }
}

} // namespace BenignPacker